---
title: "p2dds"
output: html_document
date: "2025-01-13"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### 1. Descargar la página web de la URL indicada, y almacenarlo en un formato de R apto para ser tratado.

```{r}
# Instalar los paquetes necesarios si no están instalados
if (!require(httr)) install.packages("httr")
if (!require(XML)) install.packages("XML")

# Cargar las librerías
library(httr)
library(XML)

# Paso 1: Descargar la página web
url <- "https://www.mediawiki.org/wiki/MediaWiki"
response <- GET(url)

# Comprobar el estado de la respuesta
if (status_code(response) == 200) {
  cat("Página descargada correctamente.\n")
} else {
  stop("Error al descargar la página. Código de estado: ", status_code(response))
}

# Paso 2: Convertir HTML a formato XML
html_content <- content(response, as = "text", encoding = "UTF-8")
xml_content <- htmlParse(html_content, encoding = "UTF-8")
```

### 2. Analizar el contenido de la web, buscando el título de la página (que en HTML se etiqueta como “title”).

```{r}
# Paso 3: Extraer el título de la página usando XPath
page_title <- xpathSApply(xml_content, "//title", xmlValue)

# Mostrar el título
cat("El título de la página es:", page_title, "\n")
```

### 3. Analizar el contenido de la web, buscando todos los enlaces (que en HTML se etiquetan como “a”), buscando el texto del enlace, así como la URL.

```{r}
# Paso 3: Extraer los enlaces (<a>) y sus atributos
# Extraer el texto del enlace
link_texts <- xpathSApply(xml_content, "//a", xmlValue)

# Extraer los URLs del atributo href
link_urls <- xpathSApply(xml_content, "//a/@href")

# Paso 4: Manejar posibles valores NULL en los resultados
link_texts[is.null(link_texts)] <- NA
link_urls[is.null(link_urls)] <- NA

# Paso 5: Combinar los textos y URLs en un data frame
links_df <- data.frame(
  Text = link_texts,
  URL = link_urls,
  stringsAsFactors = FALSE
)

# Mostrar una vista previa de los enlaces extraídos
print(head(links_df))

# Paso 6: (Opcional) Guardar los enlaces en un archivo CSV
#write.csv(links_df, "extracted_links.csv", row.names = FALSE)
#cat("Los enlaces extraídos se han guardado en 'extracted_links.csv'\n")
```

### 4. Generar una tabla con cada enlace encontrado, indicando el texto que acompaña el enlace, y el número de veces que aparece un enlace con ese mismo objetivo.

```{r}
# Paso 6: Contar ocurrencias de cada combinación de texto y enlace
link_summary <- as.data.frame(table(links_df$Text, links_df$URL))
colnames(link_summary) <- c("Text", "URL", "Count")

# Filtrar solo los enlaces con recuentos mayores a 0
link_summary <- link_summary[link_summary$Count > 0, ]

# Mostrar la tabla resultante
print(head(link_summary))

# Paso 7: (Opcional) Guardar la tabla en un archivo CSV
#write.csv(link_summary, "link_summary.csv", row.names = FALSE)
#cat("Resumen de enlaces guardado en 'link_summary.csv'\n")
```

### 5. Para cada enlace, seguirlo e indicar si está activo (podemos usar el código de status HTTP al hacer una petición a esa URL).

```{r}
# Paso 4: Resolver URLs relativas y absolutas
base_url <- "https://www.mediawiki.org"
resolve_url <- function(link) {
  if (is.na(link)) return(NA)
  if (grepl("^http", link)) {
    return(link)  # URL absoluta
  } else if (grepl("^//", link)) {
    return(paste0("https:", link))  # Subdominio
  } else if (grepl("^/", link)) {
    return(paste0(base_url, link))  # URL relativa
  } else if (grepl("^#", link)) {
    return(url)  # Mismo documento, diferente altura
  } else {
    return(NA)  # No válido
  }
}

resolved_urls <- sapply(link_urls, resolve_url)

# Paso 5: Crear un data.frame con texto y URLs
links_df <- data.frame(
  Text = link_texts,
  URL = resolved_urls,
  stringsAsFactors = FALSE
)

# Paso 6: Contar repeticiones de cada enlace
link_summary <- as.data.frame(table(links_df$Text, links_df$URL))
colnames(link_summary) <- c("Text", "URL", "Seen")

# Paso 7: Comprobar el estado HTTP de cada URL
# Asegurarse de que las URLs sean cadenas
link_summary$Text <- as.character(link_summary$Text)
link_summary$URL <- as.character(link_summary$URL)

# Función para verificar el estado HTTP
check_status <- function(link) {
  if (is.na(link) || link == "") return(NA)  # Manejo de NAs y cadenas vacías
  
  result <- tryCatch({
    head_response <- HEAD(link)  # Realizamos la consulta HEAD
    status_code(head_response)  # Extraemos el código de estado
  }, error = function(e) {
    return(NA)  # En caso de error, devolvemos NA
  })
  
  return(result)  # Devolvemos el código de estado
}

# Aplicar la función a las URLs
link_summary$Status <- sapply(link_summary$URL, check_status)

# Mostrar el resultado final, asegurando que los enlaces sigan siendo cadenas
link_summary$URL <- as.character(link_summary$URL)
link_summary$Status <- as.character(link_summary$Status)

# Mostrar el data.frame corregido
print(link_summary)


# Paso 8: Guardar en un archivo CSV
#write.csv(link_summary, "link_summary_with_status.csv", row.names = FALSE)
#cat("Resumen con estados HTTP guardado en 'link_summary_with_status.csv'\n")

```
